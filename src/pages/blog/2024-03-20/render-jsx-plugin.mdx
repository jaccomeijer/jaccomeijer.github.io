---
navigation:
  id: render-jsx-plugin
  url: /blog/render-jsx-plugin
date: 2024-03-20
tags: ['blog']
topics:
  opener:
    heading: Render JSX plugin for Esbuild
    abstract: Transform Esbuild generated JSX bundles to HTML pages.
    image: i20240320

---
export { BlogLayout as default } from '../../../layout/blog-layout.jsx'
import { Topic, Picture } from '@jaccomeijer/green-lib'
import { globals } from '../../../config/globals.js'
import { getOpenerTopicByNavigationId } from '../get-opener-topics.js'
import { blogImages } from '../blog-images.js'

## Esbuild as a static site generator for MDX

This post is part of a series that originated with the question "can the
Contentful-Gatsby-Netlify trio be simplified?".

<Topic
  data-variant="card"
  globals={globals}
  topic={getOpenerTopicByNavigationId({ pages: props.pages, navigationId: 'esbuild-as-static-website-generator' })}
  images={blogImages}
  swap-image={true}
/>

Using [11ty](https://www.11ty.dev) is part of the positive answer. The last
post concludes with the need for a Render JSX plugin for Esbuild.

This post starts with the code for such a plugin and describes how it works.

## The code

Below is the full plugin. It's taken from
[jaccomeijer/render-jsx-plugin-poc](https://github.com/jaccomeijer/render-jsx-plugin-poc),
a small repo that can be used to see the plugin working.

```js
import { writeFile, mkdir } from 'fs/promises'
import path from 'path'
import crypto from 'crypto'
import { render } from 'preact-render-to-string'

const pluginName = 'renderJsxPlugin'

export const renderJsxPlugin = ({ outdir, initialProps }) => {
  const setup = build => {
    build.onEnd(async result => {
      const metafileOutputs = Object.keys(result.metafile.outputs)

      for (const bundlePath of metafileOutputs) {
        const entryPoint = result.metafile.outputs[bundlePath].entryPoint

        if (!entryPoint) {
          continue
        }

        const { dir, name } = path.parse(entryPoint)
        const strippedDir = dir.replace('src/pages', '')
        const outputDir = path.join(outdir, strippedDir)
        const outputPath = path.join(outdir, strippedDir, `${name}.html`)

        const cacheBust = crypto.randomBytes(6).toString('hex')
        const modulePath = path.resolve(`./${bundlePath}?v=${cacheBust}`)
        const module = await import(modulePath)

        console.log(`${pluginName}: ${outputPath}`)

        // Check if the default export is a function
        if (typeof module?.default !== 'function') {
          continue
        }
        const props = Object.assign(initialProps || {})
        const html = render(module.default(props))

        await mkdir(path.resolve(outputDir), { recursive: true })
        await writeFile(path.resolve(outputPath), `<!DOCTYPE html>${html}`)
      }
    })
  }

  return { name: pluginName, setup }
}
```

## More capable version

A more capable version of the plugin is used in the
[jaccomeijer/green-build](https://github.com/jaccomeijer/green-build)
repository. That repo is used to build this site ([repository
here](https://github.com/jaccomeijer/jaccomeijer.github.io)) and adds
functionality like:

- image handling
- CSS bundling
- HTML minifying
- code highlighting
- page prop with Front Matter support
- pages prop for menu building
- cleanup of the javascript bundle
- custom urls
- index.html for all pages

## The breakdown

The plugin is simple and contains a few distinct steps.

### Metadata

[Esbuild](https://esbuild.github.io) provides `onEnd` plugins with build
metadata. The plugin starts with using `result.metafile` to get all bundle
paths.

```js
  const metafileOutputs = Object.keys(result.metafile.outputs)
```

### OutputPath

The plugin then loops through every `bundlePath` and derives an output dir and
path.

```js
const outputPath = path.join(outdir, strippedDir, `${name}.html`)
```

### Import bundle

Next, the the JSX bundle created by Esbuild is imported. Adding
`?v=${cacheBust}` to the module path prevents Node from caching the module.


```js
const modulePath = path.resolve(`./${bundlePath}?v=${cacheBust}`)
const module = await import(modulePath)
```

### Render to HTML

The last part of the plugin does the actual rendering.

The imported module contains a JSX function. This JSX function is usually
rendered with a library that comes with the JSX runtime. In this case, the
Preact render function from the
[preact-render-to-string](https://github.com/preactjs/preact-render-to-string)
package is used.

The JSX function accepts props like any other JSX function. This demo does not
do much with the `initialProps`, but this is how e.g. global metadata can be
passed to all pages. The package
[jaccomeijer/green-build](https://github.com/jaccomeijer/green-build), mentioned
earlier, uses this concept.

```js
const props = Object.assign(initialProps || {})
const html = render(module.default(props))
```

All that's left is writing the HTML to a file for the Esbuild webserver to
render.

All HTML documents must start with a `<!DOCTYPE>` declaration. This is not a
tag, but an id to let the browser know what to expect. This declaration is added
here.

```js
await mkdir(path.resolve(outputDir), { recursive: true })
await writeFile(path.resolve(outputPath), `<!DOCTYPE html>${html}`)
```

## JSX render

JSX is used as a simple component solution. By wrapping static HTML in a
function, this function can be reused. Simply by importing the function.
Function arguments, or 'props', make this concept dynamic.

When JSX is rendered, only the output of the JSX functions remains. This results
in static HTML.

When Javascript is needed to run with the static HTML, it can be added the same
way that Javascript is added to any static HTML. E.g. using a `<script>` tag.

The `declarative shadow dom` now being supported by Mozilla makes that custom
elements with isolated shadow dom can be generated without the need for
Javascript to activate the shadow dom.

## Conclusion

A simple extension of Esbuild lays the foundation for a great static site
generator.

JSX being just functions, they are easily added to NPM modules for distribution
and reuse. MDX always has been a great way to write documentation and stories.
Combine the two and creating a reusable and documented UI library is simpler
than ever. The next post zooms in on this.

<Topic
  data-variant="card"
  globals={globals}
  topic={getOpenerTopicByNavigationId({ pages: props.pages, navigationId: 'ui-library' })}
  images={blogImages}
  swap-image={true}
/>
