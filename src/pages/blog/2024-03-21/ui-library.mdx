---
navigation:
  id: ui-library
  url: /blog/ui-library
date: 2024-03-21
tags: ['blog']
topics:
  opener:
    heading: UI Library with MDX documentation
    abstract: Using the simple Render JSX plugin for Esbuild this post shows how to setup a powerful UI library.
    image: i20240321
  itcss:
    heading: ITCSS
    abstract: '"Specificity is inversely proportional to how many elements they affect."'
    icon: triangle

---
export { BlogLayout as default } from '../../../layout/blog-layout.jsx'
import { Topic, Picture } from '@jaccomeijer/green-lib'
import { globals } from '../../../config/globals.js'
import { getOpenerTopicByNavigationId } from '../get-opener-topics.js'
import { blogImages } from '../blog-images.js'

## Render JSX plugin for Esbuild

The last post showed a simple plugin for [Esbuild](https://esbuild.github.io).

<Topic
  data-variant="card"
  globals={globals}
  topic={getOpenerTopicByNavigationId({ pages: props.pages, navigationId: 'render-jsx-plugin' })}
  images={blogImages}
  swap-image={true}
/>

## Green build

Together with a few simple additions that handle Front Matter, CSS and images
this concept grew into
[jaccomeijer/green-build](https://github.com/jaccomeijer/green-build).

## Green lib

This post shows how to setup a small UI library that adds documentation by
writing MDX documents for each item in the library. The full
library is [available on Github](https://github.com/jaccomeijer/green-lib).

The [green reference example site](https://www.jaccomeijer.nl/green-reference/)
is created with the library to show the capabilities. It simply renders all
components.

The MDX documents of the library are [published
here](https://www.jaccomeijer.nl/green-lib/). A simple menu binds the
documentation together. The result is quite similar to a component storybook.

## Fast evolving CSS

This post is part of a series that originated with the question "can the
Contentful-Gatsby-Netlify trio be simplified?".

The original idea to put this trio together goes back to 2018. Six years later,
much has changed in the world of CSS!

### CSS Specificity

A classic CSS challenge is CSS specificity. The selector with the highest
specificity value wins. Inline styles have a specificity of 1000 which could
only be overridden by the `!important` rule. Lots of fun!

This challenge resulted in theories like the [Inverted Triangle
CSS](https://www.xfive.co/blog/itcss-scalable-maintainable-css-architecture/).

<Topic
  data-variant="quote"
  globals={globals}
  topic={frontmatter.topics.itcss}
/>

Similar concepts to manage specificity are in this library. The structure
(objects) and utility classes have a lot in common with ITCSS.

### CSS Cascade Layers

The `@layer` rule added in 2022 greatly improved managing specificity. When
importing CSS like this:

```css
@import "./css/global/reset.css" layer(reset);
@import "./css/global/markdown.css" layer(markdown);
@import "./bundles/css/structures.css" layer(structures);
@import "./bundles/css/components.css" layer(components);
@import "./bundles/css/utilities.css" layer(utilities);
```

Specificity can be managed like this:

```css
@layer reset, markdown, structures, components, utilities, custom;
```

CSS on the custom layer will always override CSS on the layers below. This is a
great way to manage the cascade. No need for the `!important` rule anymore!

### :is and :where

A concise way of writing rules and more control over specificity:

- `:is(list)` → specificity is set to the most specific selector in the argument list
- `:where(list)` → removes specificity for all selectors in the list

### Clamp

Clamp is another useful addition to modern CSS. Amongst many things, it allows
for dynamic font and space scales. This library uses scales generated at
[Utopia](https://utopia.fyi).

### Design tokens and CSS Custom Properties

Space scales are added to the project by using design tokens.

Design tokens allow for importing things like colors and spaces from Figma
directly into CSS. This library uses the
[design-tokens-cli](https://github.com/Heydon/design-tokens-cli) package to
covert Design Tokens to CSS Custom Properties.

More on that at
the  [W3C Design tokens community
group](https://www.w3.org/community/design-tokens/). This is the [latest version
of the spec](https://tr.designtokens.org/format/).

### Eslint v9

Not a CSS improvement, but working with JSX, a relevant change in the landscape.
[Eslint](https://eslint.org) finally decided on a new eslint config format
called `flat config`. The VSCode Eslint plugin has a `Experimental: Use Flat
Config` flag which makes the plugin work with the new (greatly improved!)
config.

### Native Nested CSS

The list of CSS improvements is long. Nested CSS is natively supported by all
major browsers. No more need for a CSS preprocessor to use this.

### Container queries

Another interesting addition is what is named 'container queries'. When
defining:

```css
.parent {
  container-type: inline-size;
}
```

Children of this parent can use:

```css
@container (min-width: 700px) {
  .child h3 {
    font-size: 2em;
  }
}
```

This gives a lot more control than the existing media queries.

## Web components

By experiment, two components in the library have been set up as Custom Elements
with isolated shadow DOM. The components were elected because they require
Javascript to function. 

- [navigation-header](https://www.jaccomeijer.nl/green-lib/green-lib/components/navigation-header/navigation-header/),
  uses Javascript to open the mobile menu
- [carousel-layout](https://www.jaccomeijer.nl/green-lib/green-lib/components/carousel-layout/carousel-layout/),
  uses Javascript to scroll the slides

This works well, but
faces all the problems of styling Custom Elements.


> NOTE: Zach Leatherman, author of 11ty, wrote [a great
  post](https://www.zachleat.com/web/styling-web-components/) on the modern
  issues of styling Custom Elements.

The library produces one CSS bundle which can be reused in the Custom Element.
Because the browser caches the bundle, it won't go over the line twice. Still,
this solution is not perfect. As outlined by Zach in the post mentioned above.


## Conclusion

Setting up the library was straightforward because of the simplicity and speed
of the build tool. Having a MDX document right next to the CSS provides for a
quick way to draft up a component.

CSS Layers are clearly visible in the development tools of a modern browser. A
huge improvement over guessing the specificity of a selector in the old days.

Declarative Shadow Dom is brand new. Gained support for Firefox Feb 20, 2024.
With the styling limitations, it works well.

However in small production use, this library is mainly a Proof Of Concept.

But, because of being so simple, it's a lot of fun to work with!
